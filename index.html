<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAT类型检测</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .log {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NAT类型检测工具</h1>
        
        <div id="status" class="status info">
            点击开始检测按钮启动NAT类型检测
        </div>
        
        <div>
            <button id="startBtn" class="button" onclick="startDetection()">开始检测</button>
            <button id="stopBtn" class="button" onclick="stopDetection()" disabled>停止检测</button>
        </div>
        
        <div id="result" class="result" style="display: none;">
            <h3>检测结果</h3>
            <p><strong>NAT类型:</strong> <span id="natType">-</span></p>
            <p><strong>公网IP:</strong> <span id="publicIP">-</span></p>
            <!-- <p><strong>源端口:</strong> <span id="sourcePort">-</span></p>
            <p><strong>候选端口:</strong> <span id="candidatePort">-</span></p> -->
        </div>
        
        <div class="log" id="logContainer"></div>
    </div>

    <script>
        class NATDetectionClient {
            constructor() {
                this.ws = null;
                this.pc = null;
                this.dataChannel = null;
                this.connected = false;
                this.detecting = false;
            }

            log(message) {
                const logContainer = document.getElementById('logContainer');
                const timestamp = new Date().toLocaleTimeString();
                logContainer.innerHTML += `[${timestamp}] ${message}<br>`;
                logContainer.scrollTop = logContainer.scrollHeight;
                console.log(message);
            }

            updateStatus(message, type = 'info') {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }

            async connect() {
                try {
                    this.updateStatus('正在连接WebSocket服务器...', 'info');
                    this.log('连接WebSocket服务器...');
                    
                    const 
                     = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    // 创建连接超时Promise
                    const connectTimeout = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('连接超时')), 10000); // 10秒超时
                    });
                    
                    // 创建WebSocket连接Promise
                    const connectPromise = new Promise((resolve, reject) => {
                        this.ws = new WebSocket(wsUrl);
                        
                        this.ws.onopen = () => {
                            this.log('WebSocket连接已建立');
                            this.connected = true;
                            resolve();
                        };
                        
                        this.ws.onmessage = (event) => {
                            const message = JSON.parse(event.data);
                            this.handleWebSocketMessage(message);
                        };
                        
                        this.ws.onclose = (event) => {
                            this.log(`WebSocket连接已关闭 (code: ${event.code}, reason: ${event.reason})`);
                            this.connected = false;
                            if (!this.detecting) {
                                this.updateStatus('连接已断开', 'error');
                            }
                        };
                        
                        this.ws.onerror = (error) => {
                            this.log(`WebSocket错误: ${error}`);
                            this.updateStatus('连接错误', 'error');
                            reject(error);
                        };
                    });
                    
                    // 等待连接建立或超时
                    await Promise.race([connectPromise, connectTimeout]);
                    
                    // 连接成功后设置WebRTC
                    await this.setupWebRTC();
                    
                } catch (error) {
                    this.log(`连接失败: ${error.message}`);
                    this.updateStatus('连接失败', 'error');
                    throw error;
                }
            }

            async setupWebRTC() {
                try {
                    this.log('设置WebRTC连接...');
                    
                    // 检查WebSocket连接状态
                    if (!this.connected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
                        this.log('WebSocket连接不可用，无法设置WebRTC');
                        this.updateStatus('连接已断开，请重试', 'error');
                        return;
                    }
                    
                    this.pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' }
                        ]
                    });
                    
                    this.dataChannel = this.pc.createDataChannel('nat-detection', {
                        ordered: true
                    });
                    
                    this.dataChannel.onopen = () => {
                        this.log('数据通道已打开');
                    };
                    
                    this.dataChannel.onmessage = (event) => {
                        this.log(`收到数据: ${event.data}`);
                    };
                    
                    this.pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            const candidate = event.candidate.candidate;
                            this.log(`收到ICE候选: ${candidate}`);
                            
                            // 解析ICE候选信息
                            const candidateInfo = this.parseICECandidate(candidate);
                            
                            // 只发送IPv4 UDP srflx类型的候选
                            // srflx = Server Reflexive，通过STUN服务器获得的公网映射地址
                            if (this.shouldSendCandidate(candidateInfo)) {
                                this.log(`✓ 发送有效ICE候选: ${candidateInfo.type} ${candidateInfo.protocol} ${candidateInfo.ip}:${candidateInfo.port}`);
                                this.sendWebSocketMessage({
                                    type: 'ice-candidate',
                                    candidate: event.candidate
                                });
                            } else {
                                this.log(`✗ 过滤ICE候选: ${candidateInfo.type} ${candidateInfo.protocol} ${candidateInfo.ipType} ${candidateInfo.ip}:${candidateInfo.port}`);
                            }
                        }
                    };
                    
                    this.pc.onconnectionstatechange = () => {
                        this.log(`连接状态: ${this.pc.connectionState}`);
                    };
                    
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    
                    this.log('发送本地SDP offer');
                    console.log('Generated offer SDP:', offer.sdp);
                    this.sendWebSocketMessage({
                        type: 'offer',
                        sdp: offer.sdp
                    });
                    
                    this.updateStatus('正在进行NAT检测...', 'info');
                    
                } catch (error) {
                    this.log(`WebRTC设置失败: ${error.message}`);
                    this.updateStatus('WebRTC设置失败', 'error');
                }
            }

            handleWebSocketMessage(message) {
                console.log("收到服务器消息:",message);
                this.log(`收到服务器消息: ${message.type}`);
                
                switch (message.type) {
                    case 'answer':
                        this.handleAnswer(message.sdp);
                        break;
                    case 'ice-candidate':
                        this.handleICECandidate(message.candidate);
                        break;
                    case 'nat-result':
                        this.handleNATResult(message);
                        break;
                }
            }

            async handleAnswer(sdp) {
                try {
                    this.log('收到服务器SDP answer');
                    await this.pc.setRemoteDescription({
                        type: 'answer',
                        sdp: sdp
                    });
                    this.log('成功设置远程描述');
                } catch (error) {
                    this.log(`处理Answer失败: ${error.message}`);
                    this.updateStatus('SDP设置失败', 'error');
                }
            }

            async handleICECandidate(candidate) {
                try {
                    // 检查是否已设置远程描述
                    if (!this.pc.remoteDescription) {
                        this.log('远程描述未设置，跳过ICE候选');
                        return;
                    }
                    
                    this.log(`收到服务器ICE候选: ${candidate.candidate}`);
                    await this.pc.addIceCandidate(candidate);
                    this.log('成功添加ICE候选');
                } catch (error) {
                    this.log(`添加ICE候选失败: ${error.message}`);
                }
            }

            handleNATResult(result) {
                this.log("NAT检测结果:",result);
                this.log(`NAT检测完成: ${result.natType}`);
                
                const natTypeMap = {
                    'full-cone': 'Full Cone NAT',
                    'restricted-cone': 'Restricted Cone NAT',
                    'port-restricted-cone': 'Port Restricted Cone NAT',
                    'symmetric': 'Symmetric NAT',
                    'blocked': '网络阻塞/防火墙',
                    'unknown': '未知'
                };
                
                document.getElementById('natType').textContent = natTypeMap[result.natType] || result.natType;
                document.getElementById('publicIP').textContent = result.publicIP || '未知';
                // document.getElementById('sourcePort').textContent = result.sourcePort || '未知';
                // document.getElementById('candidatePort').textContent = result.candidatePort || '未知';
                document.getElementById('result').style.display = 'block';
                
                this.updateStatus('NAT检测完成', 'success');
                this.detecting = false;
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                // 主动关闭所有连接
                this.log('检测完成，正在关闭所有连接...');
                this.disconnect();
            }

            sendWebSocketMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    this.log('WebSocket未连接，无法发送消息');
                }
            }

            parseICECandidate(candidateString) {
                // 解析ICE候选字符串
                // 格式: candidate:foundation component protocol priority ip port typ type [raddr related-address] [rport related-port]
                const parts = candidateString.split(' ');
                
                if (parts.length < 8) {
                    return null;
                }
                
                return {
                    foundation: parts[0].split(':')[1],
                    component: parts[1],
                    protocol: parts[2].toLowerCase(),
                    priority: parts[3],
                    ip: parts[4],
                    port: parts[5],
                    type: parts[7], // host, srflx, prflx, relay
                    ipType: this.getIPType(parts[4])
                };
            }

            getIPType(ip) {
                // 检查是IPv4还是IPv6
                if (ip.includes(':')) {
                    return 'ipv6';
                } else if (ip.includes('.')) {
                    return 'ipv4';
                } else {
                    return 'unknown';
                }
            }

            shouldSendCandidate(candidateInfo) {
                if (!candidateInfo) {
                    return false;
                }
                
                // 只发送IPv4 UDP srflx类型的候选
                // srflx = Server Reflexive，是通过STUN服务器获得的公网地址
                // host类型是内网地址，公网服务器无法访问
                const isValidType = candidateInfo.type === 'srflx';
                const isValidProtocol = candidateInfo.protocol === 'udp';
                const isValidIP = candidateInfo.ipType === 'ipv4';
                
                return isValidIP && isValidProtocol && isValidType;
            }

            disconnect() {
                this.log('正在断开连接...');
                
                // 清理WebRTC连接
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
                
                // 清理数据通道
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                
                // 清理WebSocket连接
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.connected = false;
                this.detecting = false;
                this.updateStatus('已断开连接', 'info');
            }
        }

        let client = null;

        async function startDetection() {
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('result').style.display = 'none';
            document.getElementById('logContainer').innerHTML = '';
            
            try {
                // 确保清理之前的连接
                if (client) {
                    client.disconnect();
                    client = null;
                }
                
                // 等待一小段时间确保连接完全关闭
                await new Promise(resolve => setTimeout(resolve, 100));
                
                client = new NATDetectionClient();
                client.detecting = true;
                await client.connect();
                
            } catch (error) {
                console.error('启动检测失败:', error);
                // 重新启用开始按钮
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                if (client) {
                    client.disconnect();
                    client = null;
                }
            }
        }

        function stopDetection() {
            if (client) {
                client.disconnect();
                client = null;
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        window.addEventListener('beforeunload', () => {
            if (client) {
                client.disconnect();
            }
        });
    </script>
</body>
</html>
