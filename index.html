<!DOCTYPE html> 
<html lang="en"> 
<head>     
    <meta charset="UTF-8">     
    <title>NAT Detector</title>
    <style>
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loader-text {
            color: #555;
        }
        .result-item {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin: 4px 0;
        }
        .result-item span {
            text-align: right;
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
            white-space: nowrap;
        }
        /* NAT Type 分级高亮色值 */
        .nat-green { color: #10b981; } /* 清新绿 */
        .nat-blue { color: #3b82f6; }  /* 明亮蓝 */
        .nat-orange { color: #f97316; }/* 活力橙 */
        .nat-red { color: #ef4444; }   /* 醒目红 */
    </style>
</head> 
<body>     
    <div id="error" style="color:red; margin:3px 0; text-align: center;"></div>     
    <div id="result" style="display:none; line-height:1.4; max-width: 500px; margin: 20px auto;">
        <div class="result-item">NAT Type: <span id="natType"></span></div>         
        <div class="result-item">Public IP: <span id="publicIP"></span></div>         
        <div class="result-item">Public Port: <span id="publicPort"></span></div>         
        <div class="result-item">IPv6: <span id="ipv6"></span></div>
        <div class="result-item">IPv6 Port: <span id="ipv6Port"></span></div>
        <div class="result-item">Connectivity: <span id="connectivity"></span></div>     
    </div>
    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">Detecting NAT information...</div>
    </div>     
    <script>         
        document.addEventListener('DOMContentLoaded', () => {             
            const dom = {                 
                err: document.getElementById('error'),                 
                res: document.getElementById('result'),                 
                nat: document.getElementById('natType'),                 
                ip: document.getElementById('publicIP'),                 
                port: document.getElementById('publicPort'),                 
                ipv6: document.getElementById('ipv6'),
                ipv6Port: document.getElementById('ipv6Port'),
                conn: document.getElementById('connectivity'),
                loader: document.getElementById('loader')
            };             
            const isSupported = !!window.RTCPeerConnection && !!window.WebSocket;             
            if (!isSupported) {                 
                dom.err.textContent = "Your browser does not support RTCPeerConnection or WebSocket";
                dom.loader.style.display = 'none';
                return;             
            }             
            const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;
            // NAT Type 颜色映射规则
            const natColorMap = {
                'Full Cone NAT': 'nat-green',
                'Restricted Cone NAT': 'nat-blue',
                'Port Restricted Cone NAT': 'nat-orange',
                'Symmetric NAT': 'nat-red'
            };             
            let detector = null;             
            class Detector {                 
                constructor() {                     
                    this.ws = null;                     
                    this.pc = null;                     
                    this.v4 = '';                     
                    this.p4 = '';                     
                    this.v6 = '';
                    this.p6 = '';
                }                 
                async run() {                     
                    dom.err.textContent = '';                     
                    dom.res.style.display = 'none';
                    [dom.nat, dom.ip, dom.port, dom.ipv6, dom.ipv6Port, dom.conn].forEach(el => {
                        el.textContent = '';
                        // 清空 NAT Type 原有颜色类
                        if(el === dom.nat) el.className = '';
                    });                     
                    try {                         
                        await this.wsConnect();                         
                        await this.rtcSetup();                     
                    } catch (e) {                         
                        dom.err.textContent = e.message || 'Detection failed';                         
                        this.clean();
                        dom.loader.style.display = 'none';                     
                    }                 
                }                 
                async wsConnect() {                     
                    const ws = new WebSocket(`${location.protocol === 'https:' ? 'wss:' : 'ws:'}//nat.mycloudgame.com/ws`);                     
                    this.ws = ws;                     
                    const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout (10s)')), 10000));                     
                    const connect = new Promise((res, rej) => {                         
                        ws.onopen = res;                         
                        ws.onmessage = e => { try { this.msgHandle(JSON.parse(e.data)); } catch (_) {} };                         
                        ws.onclose = e => e.reason && rej(new Error(`Closed: ${e.reason}`));                         
                        ws.onerror = () => {};                     
                    });                     
                    await Promise.race([connect, timeout]);                 
                }                 
                async rtcSetup() {                     
                    this.pc = new RTCPeerConnection({                         
                        iceServers: [                             
                            { urls: 'stun:stun.cloudflare.com:3478' },                             
                            { urls: 'stun:stun.l.google.com:19302' }                         
                        ]                     
                    });                     
                    this.pc.createDataChannel('nat');                     
                    this.pc.onicecandidate = e => {                         
                        if (e.candidate) {                             
                            const p = e.candidate.candidate.split(' ');                             
                            if (p.length >= 8 && p[7] === 'srflx') {
                                if (p[4].includes('.')) {
                                    this.v4 = p[4];
                                    this.p4 = p[5];
                                } else if (p[4].includes(':')) {
                                    this.v6 = p[4];
                                    this.p6 = p[5];
                                }
                                p[2] === 'udp' && this.ws.send(JSON.stringify({ type: 'ice-candidate', candidate: e.candidate }));                             
                            }                         
                        }                     
                    };                     
                    const offer = await this.pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });                     
                    await this.pc.setLocalDescription(offer);                     
                    this.ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));                 
                }                 
                msgHandle(msg) {                     
                    switch (msg.type) {                         
                        case 'nat-result':                             
                            this.showRes(msg);                             
                            break;                         
                        case 'answer':                             
                            this.pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });                             
                            break;                         
                        case 'ice-candidate':                             
                            this.pc.remoteDescription && this.pc.addIceCandidate(msg.candidate);                             
                            break;                         
                        case 'error':                             
                            dom.err.textContent = msg.message || 'Detection error';                             
                            this.clean();
                            dom.loader.style.display = 'none';                     
                    }                 
                }                 
                async showRes(res) {                     
                    const natMap = {                         
                        'full-cone': 'Full Cone NAT',                         
                        'restricted-cone': 'Restricted Cone NAT',                         
                        'port-restricted-cone': 'Port Restricted Cone NAT',                         
                        'symmetric': 'Symmetric NAT',                         
                        'blocked': 'Firewall interception',                         
                        'unknown': 'UnKnown'                     
                    };                     
                    // 连通性图标颜色修改
                    const connHtml = await fetch('https://www.cloudflare.com/cdn-cgi/trace', { method: 'HEAD' })
                        .then(() => `<span style="color: #10b981;">✓</span>`)
                        .catch(() => `<span style="color: #ef4444;">×</span>`);
                    
                    // 设置 NAT Type 文本并添加对应颜色类
                    const natTypeText = natMap[res.natType] || 'UnKnown';
                    dom.nat.textContent = natTypeText;
                    dom.nat.className = natColorMap[natTypeText] || '';
                    
                    dom.ip.textContent = res.publicIP || this.v4 || 'UnKnown';                     
                    dom.port.textContent = res.publicPort || this.p4 || 'UnKnown';                     
                    dom.ipv6.textContent = this.v6 || 'UnKnown';
                    dom.ipv6Port.textContent = this.p6 || 'UnKnown';
                    dom.conn.innerHTML = connHtml;
                    dom.res.style.display = 'block';
                    dom.loader.style.display = 'none';                     
                    this.clean();                 
                }                 
                clean() {                     
                    this.pc?.close();                     
                    this.ws?.close();
                    this.pc = this.ws = null;
                    this.v4 = this.p4 = this.v6 = this.p6 = '';
                }             
            }             
            detector = new Detector();
            detector.run();

            window.onbeforeunload = () => detector?.clean();         
        });     
    </script> 
</body> 
</html>
