<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAT类型检测</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .log {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            white-space: pre-wrap;
        }
        .compatibility {
            margin: 15px 0;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .compatibility.error {
            background-color: #f8d7da;
            color: #721c24;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NAT类型检测工具</h1>

        <div id="compatibility" class="compatibility error"></div>

        <div id="status" class="status info">
            点击开始检测按钮启动NAT类型检测
        </div>

        <div>
            <button id="startBtn" class="button" onclick="startDetection()">开始检测</button>
            <button id="stopBtn" class="button" onclick="stopDetection()" disabled>停止检测</button>
        </div>

        <div id="result" class="result" style="display: none;">
            <h3>检测结果</h3>
            <p><strong>NAT类型:</strong> <span id="natType">-</span></p>
            <p><strong>公网IP:</strong> <span id="publicIP">-</span></p>
        </div>

        <div class="log" id="logContainer"></div>
    </div>

    <script>
        // 浏览器兼容性检测
        window.addEventListener('load', () => {
            const compatEl = document.getElementById('compatibility');
            if (!window.RTCPeerConnection) {
                compatEl.textContent = "错误：你的浏览器不支持WebRTC，无法进行NAT检测";
                document.getElementById('startBtn').disabled = true;
            } else if (!window.WebSocket) {
                compatEl.textContent = "错误：你的浏览器不支持WebSocket，无法进行NAT检测";
                document.getElementById('startBtn').disabled = true;
            }
        });

        class NATDetectionClient {
            constructor() {
                this.ws = null;
                this.pc = null;
                this.dataChannel = null;
                this.connected = false;
                this.detecting = false;
            }

            log(message) {
                const logContainer = document.getElementById('logContainer');
                const timestamp = new Date().toLocaleTimeString();
                logContainer.innerHTML += `[${timestamp}] ${message}\n`;
                logContainer.scrollTop = logContainer.scrollHeight;
                console.log(`[NAT检测] ${message}`);
            }

            updateStatus(message, type = 'info') {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }

            async connect() {
                try {
                    this.updateStatus('正在连接WebSocket服务器...', 'info');
                    this.log('连接WebSocket服务器...');

                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    // 后端默认运行在本地8080端口，可根据实际修改
                    const wsUrl = `${protocol}//${window.location.hostname}:8080/ws`;
                    this.log(`WebSocket连接地址: ${wsUrl}`);

                    // 10秒连接超时
                    const connectTimeout = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('WebSocket连接超时（10秒）')), 10000);
                    });

                    const connectPromise = new Promise((resolve, reject) => {
                        this.ws = new WebSocket(wsUrl);

                        this.ws.onopen = () => {
                            this.log('WebSocket连接已建立');
                            this.connected = true;
                            resolve();
                        };

                        this.ws.onmessage = (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                this.handleWebSocketMessage(message);
                            } catch (e) {
                                this.log(`解析服务器消息失败: ${e.message}`);
                            }
                        };

                        this.ws.onclose = (event) => {
                            this.log(`WebSocket连接关闭 (状态码: ${event.code}, 原因: ${event.reason || '无'})`);
                            this.connected = false;
                            if (!this.detecting) {
                                this.updateStatus('连接已断开', 'error');
                            }
                        };

                        this.ws.onerror = (error) => {
                            this.log(`WebSocket错误: ${error.message || '未知错误'}`);
                            this.updateStatus('WebSocket连接出错', 'error');
                            reject(new Error('WebSocket连接失败'));
                        };
                    });

                    await Promise.race([connectPromise, connectTimeout]);
                    await this.setupWebRTC();

                } catch (error) {
                    this.log(`连接失败: ${error.message}`);
                    this.updateStatus(`连接失败: ${error.message}`, 'error');
                    throw error;
                }
            }

            async setupWebRTC() {
                try {
                    this.log('初始化WebRTC连接...');

                    if (!this.connected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
                        throw new Error('WebSocket未连接，无法初始化WebRTC');
                    }

                    // 配置STUN服务器，增加多个公共服务器提高成功率
                    this.pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun.cloudflare.com:3478' },
                            { urls: 'stun:stun.1und1.de:3478' }
                        ]
                    });

                    // 创建数据通道
                    this.dataChannel = this.pc.createDataChannel('nat-detection-channel', {
                        ordered: true,
                        maxRetransmits: 3
                    });

                    this.dataChannel.onopen = () => this.log('WebRTC数据通道已打开');
                    this.dataChannel.onclose = () => this.log('WebRTC数据通道已关闭');
                    this.dataChannel.onerror = (e) => this.log(`数据通道错误: ${e.message}`);

                    // 监听ICE候选
                    this.pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            const candidate = event.candidate.candidate;
                            this.log(`收到ICE候选: ${candidate.substring(0, 100)}...`);

                            const candidateInfo = this.parseICECandidate(candidate);
                            if (this.shouldSendCandidate(candidateInfo)) {
                                this.log(`发送有效候选: ${candidateInfo.type} ${candidateInfo.ip}:${candidateInfo.port}`);
                                this.sendWebSocketMessage({
                                    type: 'ice-candidate',
                                    candidate: event.candidate.toJSON()
                                });
                            } else {
                                this.log(`过滤无效候选: ${candidateInfo?.type || '未知类型'}`);
                            }
                        } else {
                            this.log('ICE候选收集完成');
                        }
                    };

                    // 监听连接状态变化
                    this.pc.onconnectionstatechange = () => {
                        const state = this.pc.connectionState;
                        this.log(`WebRTC连接状态: ${state}`);
                        if (['failed', 'disconnected'].includes(state)) {
                            this.updateStatus(`WebRTC连接${state}`, 'error');
                        }
                    };

                    // 创建并发送SDP Offer
                    const offer = await this.pc.createOffer({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    });
                    await this.pc.setLocalDescription(offer);

                    this.log('发送SDP Offer到服务器');
                    this.sendWebSocketMessage({
                        type: 'offer',
                        sdp: offer.sdp
                    });

                    this.updateStatus('正在检测NAT类型...', 'info');

                } catch (error) {
                    this.log(`WebRTC初始化失败: ${error.message}`);
                    this.updateStatus('WebRTC初始化失败', 'error');
                    throw error;
                }
            }

            handleWebSocketMessage(message) {
                if (!message.type) return;
                this.log(`收到服务器消息类型: ${message.type}`);

                switch (message.type) {
                    case 'answer':
                        this.handleAnswer(message.sdp);
                        break;
                    case 'ice-candidate':
                        this.handleICECandidate(message.candidate);
                        break;
                    case 'nat-result':
                        this.handleNATResult(message);
                        break;
                    case 'error':
                        this.updateStatus(`服务器错误: ${message.msg}`, 'error');
                        this.log(`服务器错误: ${message.msg}`);
                        break;
                }
            }

            async handleAnswer(sdp) {
                try {
                    await this.pc.setRemoteDescription({ type: 'answer', sdp });
                    this.log('成功设置远程SDP Answer');
                } catch (error) {
                    this.log(`处理SDP Answer失败: ${error.message}`);
                    this.updateStatus('SDP协商失败', 'error');
                }
            }

            async handleICECandidate(candidate) {
                try {
                    if (!this.pc.remoteDescription) {
                        this.log('远程SDP未设置，暂存ICE候选');
                        return;
                    }
                    await this.pc.addIceCandidate(new RTCIceCandidate(candidate));
                    this.log('成功添加服务器ICE候选');
                } catch (error) {
                    this.log(`添加ICE候选失败: ${error.message}`);
                }
            }

            handleNATResult(result) {
                this.log(`检测完成 | NAT类型: ${result.natType} | 公网IP: ${result.publicIP}`);
                // 映射友好的NAT类型名称
                const natTypeMap = {
                    'full-cone': '全锥形NAT',
                    'restricted-cone': '受限锥形NAT',
                    'port-restricted-cone': '端口受限锥形NAT',
                    'symmetric': '对称型NAT',
                    'blocked': '网络阻塞/防火墙拦截',
                    'unknown': '未知类型'
                };

                document.getElementById('natType').textContent = natTypeMap[result.natType] || result.natType;
                document.getElementById('publicIP').textContent = result.publicIP || '未知';
                document.getElementById('result').style.display = 'block';

                this.updateStatus('NAT检测完成', 'success');
                this.detecting = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;

                // 检测完成后自动断开连接
                setTimeout(() => this.disconnect(), 5000);
            }

            sendWebSocketMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    this.log('WebSocket未连接，消息发送失败');
                }
            }

            parseICECandidate(candidateString) {
                const parts = candidateString.split(' ');
                if (parts.length < 8) return null;
                return {
                    foundation: parts[0].split(':')[1],
                    component: parts[1],
                    protocol: parts[2].toLowerCase(),
                    priority: parseInt(parts[3]),
                    ip: parts[4],
                    port: parseInt(parts[5]),
                    type: parts[7],
                    ipType: parts[4].includes(':') ? 'ipv6' : parts[4].includes('.') ? 'ipv4' : 'unknown'
                };
            }

            shouldSendCandidate(candidateInfo) {
                // 只发送 IPv4 + UDP + 服务器反射型（srflx）候选
                return candidateInfo &&
                    candidateInfo.type === 'srflx' &&
                    candidateInfo.protocol === 'udp' &&
                    candidateInfo.ipType === 'ipv4';
            }

            disconnect() {
                this.log('开始清理连接资源...');
                if (this.dataChannel) this.dataChannel.close();
                if (this.pc) this.pc.close();
                if (this.ws) this.ws.close(1000, '检测完成');
                this.connected = false;
                this.detecting = false;
                this.updateStatus('已断开所有连接', 'info');
            }
        }

        let client = null;

        async function startDetection() {
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('result').style.display = 'none';
            document.getElementById('logContainer').textContent = '';

            try {
                // 清理旧连接
                if (client) {
                    client.disconnect();
                    client = null;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                client = new NATDetectionClient();
                client.detecting = true;
                await client.connect();

            } catch (error) {
                console.error('检测启动失败:', error);
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                if (client) client.disconnect();
                client = null;
            }
        }

        function stopDetection() {
            if (client) {
                client.disconnect();
                client = null;
            }
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = '检测已手动停止';
            document.getElementById('status').className = 'status info';
        }

        // 页面关闭时清理连接
        window.addEventListener('beforeunload', () => {
            if (client) client.disconnect();
        });
    </script>
</body>
</html>
